module Main
  ( main
  ) where

import Data.List as List
import Data.Set as Set

type Coordinates = (Double, Double)

input =
  [ "#.....#...#.........###.#........#.."
  , "....#......###..#.#.###....#......##"
  , "......#..###.......#.#.#.#..#......."
  , "......#......#.#....#.##....##.#.#.#"
  , "...###.#.#.......#..#..............."
  , "....##...#..#....##....#...#.#......"
  , "..##...#.###.....##....#.#..##.##..."
  , "..##....#.#......#.#...#.#...#.#...."
  , ".#.##..##......##..#...#.....##...##"
  , ".......##.....#.....##..#..#..#....."
  , "..#..#...#......#..##...#.#...#...##"
  , "......##.##.#.#.###....#.#..#......#"
  , "#..#.#...#.....#...#...####.#..#...#"
  , "...##...##.#..#.....####.#....##...."
  , ".#....###.#...#....#..#......#......"
  , ".##.#.#...#....##......#.....##...##"
  , ".....#....###...#.....#....#........"
  , "...#...#....##..#.#......#.#.#......"
  , ".#..###............#.#..#...####.##."
  , ".#.###..#.....#......#..###....##..#"
  , "#......#.#.#.#.#.#...#.#.#....##...."
  , ".#.....#.....#...##.#......#.#...#.."
  , "...##..###.........##.........#....."
  , "..#.#..#.#...#.....#.....#...###.#.."
  , ".#..........#.......#....#.........."
  , "...##..#..#...#..#...#......####...."
  , ".#..#...##.##..##..###......#......."
  , ".##.....#.......#..#...#..#.......#."
  , "#.#.#..#..##..#..............#....##"
  , "..#....##......##.....#...#...##...."
  , ".##..##..#.#..#.................####"
  , "##.......#..#.#..##..#...#.........."
  , "#..##...#.##.#.#.........#..#..#...."
  , ".....#...#...#.#......#....#........"
  , "....#......###.#..#......##.....#..#"
  , "#..#...##.........#.....##.....#...."
  ]

zipWith2dIndex :: [[a]] -> [((Double, Double), a)]
zipWith2dIndex xss =
  [((i, j), x) | (j, xs) <- zip [0 ..] xss, (i, x) <- zip [0 ..] xs]

parse :: [String] -> Set Coordinates
parse inputLines =
  Set.fromList . Prelude.map fst $
  Prelude.filter (('#' ==) . snd) (zipWith2dIndex inputLines)

f :: Set Coordinates -> [(Coordinates, Double)]
f s =
  [ ((x, y), atan2 (x - x2) (y - y2))
  | (x, y) <- (toList s)
  , (x2, y2) <- (toList s)
  , (x, y) /= (x2, y2)
  ]

g x =
  List.map
    List.length
    (List.map
       nub
       (List.map
          (List.map snd)
          ((List.groupBy (\(a, b) (x, y) -> a == x) (f s)))))
  where
    s = parse x

part1 = maximum $ g input

-----------

best =
  toList (parse input) !!
  (fst (head (List.filter (\(a, b) -> b == part1) (zip [0 ..] (g input)))))

z :: Set Coordinates -> [(Coordinates, Coordinates)]
z s =
  [ ((x2, y2), ((atan2 (-x + x2) (-y + y2)), ((x - x2) ^ 2 + (y - y2) ^ 2)))
  | (x, y) <- [best]
  , (x2, y2) <- (toList s)
  , (x, y) /= (x2, y2)
  ]

pl = sortBy (\(_, (x, y)) (_, (a, b)) -> compare (a, b) (x, y)) (z . parse $ input)

plg = groupBy (\(_, (x, _)) (_, (y, _)) -> x == y) pl

part2 = (concat $ transpose plg) !! 199

main :: IO ()
main = do
  print $ part1
  print $ part2
