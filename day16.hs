module Main (main) where

digits :: String -> [Int]
digits = map (read . (:[]))

input :: [Int]
input = (digits "59791871295565763701016897619826042828489762561088671462844257824181773959378451545496856546977738269316476252007337723213764111739273853838263490797537518598068506295920453784323102711076199873965167380615581655722603274071905196479183784242751952907811639233611953974790911995969892452680719302157414006993581489851373437232026983879051072177169134936382717591977532100847960279215345839529957631823999672462823375150436036034669895698554251454360619461187935247975515899240563842707592332912229870540467459067349550810656761293464130493621641378182308112022182608407992098591711589507803865093164025433086372658152474941776320203179747991102193608")

pattern :: [Int]
pattern = [0, 1, 0, -1]

cycledPattern n = drop 1 . cycle . concat $ map (\x -> replicate n x) pattern

fft l 0 = l
fft l i = fft (map (\m -> (`mod` 10) . abs . sum $ zipWith (*) l (cycledPattern m)) [1..length l]) (i - 1)

part1 = take 8 $ concat $ map show (fft input 100)

------------------------

fromDigits :: [Int] -> Int
fromDigits = read . concatMap show

input2 :: [Int]
input2 = concat $ replicate 10000 input

offset :: Int
offset = fromDigits $ take 7 input2

w l = scanl1 (\x y -> (x + y) `mod` 10) l

part2 = take 8 $ drop 5979187 input2 -- $ concat $ List.map show (fft input2 100)

main :: IO ()
main = do
  print part1
  print part2
  