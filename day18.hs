module Main (main) where

import Data.Char as Char
import Data.Function as Function
import Data.List as List
import Data.Map as Map
import Data.Ord as Ord
import Data.Set as Set
import Data.Tuple as Tuple
import Data.Sequence as Sequence

import Debug.Trace as Trace

t3 =
  "#########\n\
  \#b.A.@.a#\n\
  \#########"

t2 =
  "########################\n\
  \#@..............ac.GI.b#\n\
  \###d#e#f################\n\
  \###A#B#C################\n\
  \###g#h#i################\n\
  \########################"

t1 =
  "#################\n\
  \#i.G..c...e..H.p#\n\
  \########.########\n\
  \#j.A..b...f..D.o#\n\
  \########@########\n\
  \#k.E..a...g..B.n#\n\
  \########.########\n\
  \#l.F..d...h..C.m#\n\
  \#################"
----------------

t4 =
  "########################\n\
  \#...............b.C.D.f#\n\
  \#.######################\n\
  \#.....@.a.B.c.d.A.e.F.g#\n\
  \########################"

input = 
  "#################################################################################\n\
  \#..........c#.............E.......#.....#.....#...#.........#...#...............#\n\
  \#.#########.#.#.#################.#.#####.#.#.#.#.#.#######.#.#.#.#########.#####\n\
  \#.#...R...#.#.#.#.#.....#.....#.#.#....t#.#.#.#.#.#.#.....#...#...#.......#.....#\n\
  \###.#####.#.#G#.#.#.#.###.#.#.#.#.#####.###.###.#.#.###.#.###############.#####.#\n\
  \#...#.....#...#.#...#.....#.#...#.....#.#...#...#.#...#.#p........#...........#.#\n\
  \#.#####.#######.#####.#####.#########V#.#.###.###.###.#.#######.#.#.#####.#####.#\n\
  \#.#...#.....#...#...#.....#...#...#...#.#...#...#...#.#.#.....#.#.#.....#.#.....#\n\
  \#.#.#W#####.#.###.#.#########.#.#.#.###.#.#.###.###.#.###.###.#.#.#.###.###.###.#\n\
  \#...#.#.#...#.#...#.....#.....#.#...#...#.#...#.#.#.#...#.#...#.#.#...#.#...#.#.#\n\
  \#####.#.#.###.#.#.#####.#.#.###.#####.###.#.#.#.#.#.###.#.#.###.#.#####.#.###.#.#\n\
  \#.....#.#...#.#d#.#...#o#.#.#...#.#.....#.#.#.#.#.#...#j#.#x#...#.......#.#.#...#\n\
  \#.#####.###.#.#.###.#.#.#.###.###.#.###.#.#.#.#.#.###.#.#.#.#.###.#####.#.#.#.###\n\
  \#.....#...#...#.....#.#.#...#.#.....#...#.#.#.#.....#.#...#...#...#...#.#.#.#.#.#\n\
  \#.###.###.###.#######.#.#.#.#.#####.#.###.#.#######.#.#####.#####.#.#.###.#.#.#.#\n\
  \#.#.#...#.....#...#...#.#.#.#.....#.#...#.#.#.......#...#...#...#.#.#.....#.#.#.#\n\
  \#.#A###.#.#######.#.###Q###.#####.#####.#.#.#.#######.###.###.#.###.#######.#.#.#\n\
  \#.#...#.#.........#...#...#...#...#.....#.#.........#.....#.#.#...#.#.......#w#.#\n\
  \#.#.#.#.#########.###.###.###.#.###.###.#####.###########.#.#.###.#.#####.#.#.#.#\n\
  \#...#.#...#.......#..s#.....#.#...#.#.#.#...#.#.........#...#.#...#.#...#.#...#.#\n\
  \###.#####.#########.#######.#.###.#.#.#.#.#.#.#.#######.###.#.#.###.#.#.###.###.#\n\
  \#...#...#.......#...#...#...#...#...#...#.#.#.#.#...#...#...#.#...#...#...#.....#\n\
  \#.###.#.#######.#.#.###.#.#####.#####.###.#.###.#.#.#.#.#########.#.#####.#####.#\n\
  \#n..#.#.......#.#.#...#.#.....#.....#...#.#.....#.#.#.#.#.....#...#.....#.....#a#\n\
  \###.#.#######.#.#.#####.#####.#.###.###.#.#######.#.#.#.#.#.###.#######.#####.#.#\n\
  \#...#.#.....#...#.....#.#...#.#...#...#.#.#.....#.#...#.#.#.#...#.....#.....#.#.#\n\
  \#.###.#.###.#########.#K#.###B###.#####.#.#.###.#.#######.#.#.#####.#.#####.#.#.#\n\
  \#.#.#.....#.#.......#...#...#...#...#...#.#...#.#.....#...#...#...#.#...#...#.#.#\n\
  \#.#.#######.#.#####.#######.###.###.#.###.###.#.#####.#.#######.#.#.#.###.###.#.#\n\
  \#...#...#...#...#i#...#.......#...#.....#.#...#.#...#...#.....#.#.#.#.#...#.#.#.#\n\
  \###.#.###.#####.#.#.###.#.#######.#####.#.#.#####.#.#####.###.#.#.#.#.#.###.#.#.#\n\
  \#...#.#...#.....#.#...#.#.......#...#...#.#.......#.....#...#...#.#.#.......#.#.#\n\
  \#.###.#.#.#.#####.###.#.#######.###.#.###.#######.###.#.###.#####.###.#######.###\n\
  \#.#...#.#.#.#.....#...#...#.#...#...#...#...#...#...#.#.....#...#...#.#.....#...#\n\
  \#.###.#.###.#.###.#.#.###.#.#.###.#####.###.#.#.###.#.#######.#.###.###.###.###.#\n\
  \#...#.#.#...#..z#.#.#...#.#.#...#.#.....#...#.#.#...#.....#.#.#...#.....#.#...#.#\n\
  \###.#.#.#.###.#.#.#.#####.#.###.#.#.#####.###.#.#########.#.#.###.#######.###.#.#\n\
  \#.#...#.#...#.#.#.#.......#...#...#...#.#.....#.........#.#.#.#...#.......#...#.#\n\
  \#.###.#.###.#.#.###########.#.#######.#.###############.#.#.#.#.###.#.#####.###.#\n\
  \#.....#.....#.#.......H.....#........................h....#...#.....#...........#\n\
  \#######################################.@.#######################################\n\
  \#....m....#.#.........#.....#.............#...#...............#.........#.......#\n\
  \#.#.#####.#.#.#######.#.#####.###.#####.#.#.#.#.#.#.###########.#####.#.#.#.#####\n\
  \#.#.#.....#.#...#...#.#.#.....#.#.#...#.#.#.#...#.#.#.....#.....#.I...#...#.#...#\n\
  \#.#.###.###.###.#.#.#.#.#.#####.#.#.#.#.#.#.#####.###.###.#.#####.#####.#####.#.#\n\
  \#.#...#.......#.#.#...#.#.......#.#.#.#.#...#...#.......#...#.....#...#.#.....#.#\n\
  \#.###.#######.#.#.#####.#######.#.#.#.#.#####.#.#######.#####.#####.###.#.#####.#\n\
  \#...#.....#...#.#.#.......#.....#...#.#.#.....#.....#.#.#...#.....#.....#.#....b#\n\
  \#.#######.#.###.#.#######.#.#########.###.#########.#.#.###.#####.#.#####.#.#####\n\
  \#.#.......#u..#.#.......#.#...#.#...#...#.#...#.#...#.......Z.#...#...#q..#.#...#\n\
  \###.###########.#######.#.###.#.#.#.#.#.#.#.#.#.#.###.#########.#######.###.#.#.#\n\
  \#...#.L.......#...#...#.#...#...#.#.#.#.#...#.#.#.#...#.........#.......#...#.#.#\n\
  \#.###.#######.###.###.#.#.#.#.###.#.###.#####.#.#.#.###.#####.###.#######U#####.#\n\
  \#y....#.....#...#.....#.#.#...#...#.....#.....#.#.#...#...#.#.#...#.....#.......#\n\
  \#.#####.#######.#####.#.#######.#######.#.#####.#.#######.#.#.#.#####.#########.#\n\
  \#.#..f..#.......#.....#...#.....#.....#.#...#.......#.....#...#.#...#.#.......#.#\n\
  \#.#.#####.#####.#.#######.#.#####.###.#.#.#.#######.#.#######.#.#.#.#M#.###.###.#\n\
  \#.#.#...#.....#.#...#.....#...#.....#.#.#.#.....#.#.#.#.....#.#.#.#...#...#.....#\n\
  \#.#.#.#.#.###.#.###.#.#####.#.#####.###.#######.#.#.#.#.###.###.#.#.#####.#######\n\
  \#...#.#.#...#.#...#.#.#...#.#.....#.#...#.......#.#...#.#.#.....#.#.#.F...#.....#\n\
  \#####.#.###.#.#####.#.#.###.#####.#.#.###.#######.#.###.#.#.#####.###.#######.#Y#\n\
  \#.....#...#.#.....#.#.#...#.....#.#.#...#.....#...#.#...#.#.#.#.......#.......#.#\n\
  \#.#######.#######.#.###.#.###.###.#.###.#.###.#.###.#.###.#.#.#######.###.#####.#\n\
  \#.#...............#...#.#.#...#...#.....#...#.#.#...#.#...O.#.......#.....#.....#\n\
  \#.#############.#####.#.#.#.###.###.#######.#.#.#.###D#############.#######.#####\n\
  \#.........#...#.#...#.#.#...#.#.#.#.#...#...#.#.#...#.....#.......#...#...#.....#\n\
  \#########.#.#.###.#.#.#.#####.#.#.#.#.#######.#C###.#####.#.#.#######.###.#####.#\n\
  \#.....#...#.#...#r#.#.#.......#.#.#.#...#.....#...#.#...#...#.S.#..k..#.....#...#\n\
  \#.###.#.#.#.###.#.#.#.#########.#.#.#.#.#.#####.#.#.###.#######.#.#####.#####.###\n\
  \#.#.#.#.#.#.#.#...#.#.#...#...#.#...#.#.#.#.....#.#.....#.....#...#...........#.#\n\
  \#.#.#.#.#.#.#.#####.#.#.#.#.#.#.#.#####.#.#.#.#####.#####.###.#####.###########.#\n\
  \#.#.....#.#...#.#...#.#.#.#.#v..#.......#.#.#.#.....#...#...#.#...#...#.......#.#\n\
  \#.###########.#.#.#.#.#.#.#.###########.#.###.#.#####.#.###.#.#.#.###.#.#.###.#P#\n\
  \#...............#.#.#..e#...#...#.T.....#...#.#.#.....#...#.#...#.....#.#.#l#...#\n\
  \#.###############.#.#########.###.#######.#.#.#.#.#######.#.###########.#.#.###.#\n\
  \#.#.........#.....#.#...#.......#.#.....#.#.#...#.#.....#...#.J...#...#.#.#.....#\n\
  \#.#######.#.#.#######.#.#.#####.#.#.###.#.#.#####.#.###.#####.###.###.#.#.###.###\n\
  \#.........#.#.....#...#.#.....#...#.#.#.#.#.#.....#.#.........#.#...#...#.X.#...#\n\
  \###########.#####.#.###.#####.#####.#.#.#.#.#.#######.#########.###.#######.###.#\n\
  \#...............#.....#.............#..g#.#.......N...#.....................#...#\n\
  \#################################################################################"

type Position = (Int, Int)
type Maze = Map Position Char

mazeFromString :: String -> Maze
mazeFromString string = Map.fromList . concat $ List.map (\(y, l) -> List.map (\(x, v) -> ((x, y), v)) l) (Prelude.zip [0 ..] (List.map (Prelude.zip [0 ..]) (lines string)))

positionOf :: Maze -> Char -> Position
positionOf maze x = head . Map.keys . Map.filter (x ==) $ maze

allKeys :: Maze -> Set Char
allKeys maze = Set.fromList . Map.elems . Map.filter isAsciiLower $ maze

part1 :: String -> Int
part1 str = bfs Set.empty ((0, (positionOf maze '@'), Set.empty, Set.empty) :<| Empty)
  where
    maze = mazeFromString str
    bfs repeated ((distance, (x, y), visited, keysCollected) :<| nodes)
      | keysCollected == allKeys maze = distance
      | isAsciiLower current && not (current `Set.member` keysCollected) = bfs repeated ((distance, (x, y), Set.empty, (Set.insert current keysCollected)) :<| nodes)
      | otherwise = bfs (List.foldr Set.insert repeated (List.map (\(_, (x', y'), _, keysCollected') -> ((x', y'), keysCollected')) $ toVisit)) (nodes >< Sequence.fromList toVisit)
      where
        cell (a, b) = if distance `mod` 100 == 0 then trace (show (distance, (x, y), keysCollected)) $ 
                                                  Map.findWithDefault '#' (a, b) maze
                                             else Map.findWithDefault '#' (a, b) maze
        canGoIfDoor a = if isAsciiUpper a then toLower a `Set.member` keysCollected else True
        current = cell (x, y)
        visited' = Set.insert (x, y) visited
        toVisit = List.map (\(x', y') -> (distance + 1, (x', y'), visited', keysCollected)) .
                    List.filter 
                    (\dir -> not ((dir, keysCollected) `Set.member` repeated) && not (dir `Set.member` visited) && cell dir /= '#' && canGoIfDoor (cell dir)) $
                    [(x, y + 1), (x, y - 1), (x + 1, y), (x - 1, y)]

--------------------------------

dividedMazeFromString :: String -> (Maze, (Int, Int))
dividedMazeFromString string = (maze, (a,b))
  where
    maze' = Map.insert (a + 1, b - 1) '@' .
            Map.insert (a + 1, b + 1) '@' .
            Map.insert (a - 1, b - 1) '@' .
            Map.insert (a - 1, b + 1) '@' .
            Map.insert (a, b - 1) '#' .
            Map.insert (a, b + 1) '#' .
            Map.insert (a + 1, b) '#' .
            Map.insert (a - 1, b) '#' . 
            Map.insert (a, b) '#' 
            $ maze
    (a,b) = positionOf maze '@'
    maze = mazeFromString string

----------------------------

t21 =
  "#######\n\
  \#a.#Cd#\n\
  \##...##\n\
  \##.@.##\n\
  \##...##\n\
  \#cB#Ab#\n\
  \#######"

t22 =
  "#############\n\
  \#DcBa.#.GhKl#\n\
  \#.###...#I###\n\
  \#e#d#.@.#j#k#\n\
  \###C#...###J#\n\
  \#fEbA.#.FgHi#\n\
  \#############"

part2 :: String -> Int
part2 str = bfs (mazeULQuadrant) Set.empty ((0, (apos - 1, bpos - 1), Set.empty, Set.empty) :<| Empty) +
            bfs (mazeURQuadrant) Set.empty ((0, (apos + 1, bpos - 1), Set.empty, Set.empty) :<| Empty) +
            bfs (mazeLLQuadrant) Set.empty ((0, (apos - 1, bpos + 1), Set.empty, Set.empty) :<| Empty) +
            bfs (mazeLRQuadrant) Set.empty ((0, (apos + 1, bpos + 1), Set.empty, Set.empty) :<| Empty)
  where
    (maze, (apos, bpos)) = dividedMazeFromString str
    mazeULQuadrant = Map.filterWithKey (\(a, b) c -> a < apos && b < bpos) maze
    mazeURQuadrant = Map.filterWithKey (\(a, b) c -> a > apos && b < bpos) maze
    mazeLLQuadrant = Map.filterWithKey (\(a, b) c -> a < apos && b > bpos) maze
    mazeLRQuadrant = Map.filterWithKey (\(a, b) c -> a > apos && b > bpos) maze
    bfs m repeated ((distance, (x, y), visited, keysCollected) :<| nodes)
      | allKeys m `Set.isSubsetOf` keysCollected = distance
      | isAsciiLower current && not (current `Set.member` keysCollected) = bfs m repeated ((distance, (x, y), Set.empty, (Set.insert current keysCollected)) :<| nodes)
      | otherwise = bfs m (List.foldr Set.insert repeated (List.map (\(_, (x', y'), _, keysCollected') -> ((x', y'), keysCollected')) $ toVisit)) (nodes >< Sequence.fromList toVisit)
      where
        cell (a, b) = if distance `mod` 100 == 0 then trace (show (distance, (x, y), keysCollected)) $ 
                                                  Map.findWithDefault '#' (a, b) m
                                              else Map.findWithDefault '#' (a, b) m
        canGoIfDoor a = if (toUpper a) `Set.member` (allKeys m) then toLower a `Set.member` keysCollected else True
        current = cell (x, y)
        visited' = Set.insert (x, y) visited
        toVisit = List.map (\(x', y') -> (distance + 1, (x', y'), visited', keysCollected)) .
                    List.filter 
                    (\dir -> not ((dir, keysCollected) `Set.member` repeated) && not (dir `Set.member` visited) && cell dir /= '#' && canGoIfDoor (cell dir)) $
                    [(x, y + 1), (x, y - 1), (x + 1, y), (x - 1, y)]


main :: IO ()
main = do
  print ""
